import time
from datetime import datetime
import random

from src.wallet import balances
from src.setup_logger import logger, balance_logger
from src.params import RATE_LIMIT_FACTOR, EXPLOIT_THREAD_DELAY, OPERATE_THR_FACTOR, PROFIT_THR_TO_OPEN_POSITIONS, NON_DIRECT_TRADE_PROFIT_THR, NON_DIRECT_CLOSING_PROFIT_THR
from src.params import TRADING_SIZE_MARGIN, TRADING_SIZE, TRADES_TO_ALLOW_CLOSING, PROFIT_THR_TO_CLOSE_POSITIONS, MAX_ITER_TO_EXIT
from src.storage import storage
from src.selling_buying import selling_order_demo, buying_order_demo, get_selling_price, get_buying_price


current_milli_time = lambda: int(round(time.time() * 1000))

def exploit_thread(exch_0, exch_1, coin_pair, coin_pairs_avail):
    """
        exploit thread
        it tracks a profit tendency between exchanges and coins pair
        stores the profit until the tendence turns into negative or not profitable
    """

    RATE_LIMIT_FACTOR = 1  # set a lower

    # compose the log filename using exchanges and coins pair
    filename = './logs/' + exch_0.name + '-' + exch_1.name + '-' + coin_pair.replace('/', '-') + '.csv'


    thread_name = storage.exploit_threads[-1].getName()
    logger.info('{} STARTING'.format(thread_name))

    # movements accumulated
    acc_base_exch_1 = 0    # on exch 1
    acc_eq_base_exch_0 = 0 # accum equivalent base amoun on exch_0

    # statistics data, still not used
    iterations = 1
    iterations_failed = 0
    acc_profit = 0

    mean_profit = 0
    ready_to_exit = True

    while True:
        loop_time = time.time()
        now = datetime.now()

        if  exch_0.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_0.lastRestRequestTimestamp) > 0:
            time.sleep((exch_0.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_0.lastRestRequestTimestamp))/1000)

        if  exch_1.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_1.lastRestRequestTimestamp) > 0:
            time.sleep((exch_1.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_1.lastRestRequestTimestamp))/1000)
        
        # gets the trading sizes and coins names
        base_coin = coin_pair.split('/')[0]
        quote_coin = coin_pair.split('/')[1]

        tz_base =  balances.get_coin_balance(exch_0.name, base_coin)['trading_size']
        tz_quote = balances.get_coin_balance(exch_1.name, quote_coin)['trading_size']
        tz_BTC = balances.get_coin_balance(exch_1.name, 'BTC')['trading_size']
        tz_USD = balances.get_coin_balance(exch_1.name, 'USD')['trading_size']
        tz_EUR = balances.get_coin_balance(exch_1.name, 'EUR')['trading_size']

        base_coin_balance_0 = balances.get_coin_balance(exch_0.name, base_coin)['amount']
        quote_coin_balance_1 = balances.get_coin_balance(exch_1.name, quote_coin)['amount']

        base_coin_balance_1 = balances.get_coin_balance(exch_1.name, base_coin)['amount']
        quote_coin_balance_0 = balances.get_coin_balance(exch_0.name, quote_coin)['amount']

        # get the best bid and ask for that amount
        bid = get_selling_price(exch_0, coin_pair, tz_base)
        ask = get_buying_price (exch_1, coin_pair, tz_quote)

        # gets the fees
        try:
            fee_0 = max(exch_0.fees['trading']['maker'], exch_0.fees['trading']['taker'])
        except:
            fee_0 = 0.005
        try:
            fee_1 = max(exch_1.fees['trading']['maker'], exch_1.fees['trading']['taker'])
        except:
            fee_1 = 0.005

        if not bid or not ask:
            logger.info('{}: not enough volume for ordering selling-buying'.format(thread_name))
            logger.warning('{}: possible rate limit violation, take care at this working conditions!'.format(thread_name))
            # delay time with a bit of stagger to avoid always falling on same point
            time.sleep(EXPLOIT_THREAD_DELAY + random.randint(0, 3))
            continue

        # figure the profit out. Operation Threshold: factor above fees
        profit = (bid - ask)/ask - OPERATE_THR_FACTOR * (fee_0 + fee_1)

        if profit >= PROFIT_THR_TO_OPEN_POSITIONS:
            logger.info('{}: trading possible, net profit: \t{}'.format(thread_name, profit))
            acc_profit += profit
            # storage.accumProfit += profit
            mean_profit = acc_profit/iterations

            # option 0: ideal: base and quote OK
            keep_running = True
            logger.info('{}: ordering selling-buying profit \t{}'.format(thread_name, profit))
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base * (1+fee_0) \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN *(tz_quote * (1+fee_1) * ask):
                    logger.info('{} OPTION 0, ideal situation: cash in base coin in first exch and cash in quote coin in second exch'.format(thread_name))

                    # ----------------------------------------------------------------------
                    selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)
                    buying_order_demo (exch_1, coin_pair, ask, tz_base, fee_1)
                    # ----------------------------------------------------------------------

                    balances.update_profit(exch_0.name, base_coin, tz_base * profit)
                    # acc_quote_exch_0 += tz_base * bid
                    acc_eq_base_exch_0 += tz_base * (1 + profit)
                    acc_base_exch_1 += tz_base

                    iterations += 1
                    ready_to_exit = False
                    keep_running = False

        elif profit >= NON_DIRECT_TRADE_PROFIT_THR:  # here we have to set a higher threshold since we could get into big losses ...
            keep_running = True

            # option 1: USD and quote OK
            if balances.get_coin_balance(exch_0.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * (tz_quote * (1+fee_1) * ask) \
                and quote_coin + '/USD' in exch_0.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 1 cash in USD in first exch and cash in quote coin in second exch'.format(thread_name))

                    # exch0: buy quote coin using USD, exch1: buy base coin (using quote)
                    pair_to_buy = quote_coin + '/USD'
                    ask_0 = get_buying_price(exch_0, pair_to_buy, tz_quote)
                    if ask:
                        # ----------------------------------------------------------------------
                        buying_order_demo(exch_0, pair_to_buy, ask_0, tz_quote, fee_0)  # USD
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_quote * profit)  # update profit on one of the exchanges<- TODO

                        acc_eq_base_exch_0 += tz_base * (1 + profit)
                        acc_base_exch_1 += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 1, not possible get get an ask value'.format(thread_name))

            # option 2: base and USD OK
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base * (1+fee_0) \
                and balances.get_coin_balance(exch_1.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and base_coin + '/USD' in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 2 cash in base coin in first exch and cash in USD in second exch'.format(thread_name))

                    # exch0: SELL base coin (using quote), exch1: BUY base coin using USD
                    pair_to_buy = base_coin + '/USD'
                    ask_1 = get_buying_price(exch_1, pair_to_buy, tz_base)
                    if ask:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)
                        buying_order_demo (exch_1, pair_to_buy, ask_1, tz_base, fee_1)  # USD
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)  # update profit on one of the exchanges<- TODO

                        acc_eq_base_exch_0 += tz_base * (1 + profit)
                        acc_base_exch_1 += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 2, not possible get get an ask value'.format(thread_name))

            # option 3: USD and USD
            if balances.get_coin_balance(exch_0.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and balances.get_coin_balance(exch_1.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and quote_coin + '/USD' in exch_0.markets.keys() \
                and base_coin + '/USD' in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 3 cash in USD coin in first exch and cash in USD in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using USD), exch1: BUY base coin using USD
                    
                    pair_to_buy_0 = quote_coin + '/USD'
                    pair_to_buy_1 = base_coin + '/USD'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # USD
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # USD
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_quote * profit)  # update profit on one of the exchanges

                        acc_eq_base_exch_0 += tz_base * (1 + profit)              # TODO: create an new storage for this moved amounts USD->quote_coin to close position 
                        acc_base_exch_1  += tz_base                               # TODO: create an new storage for this moved amounts USD->base_coin to close position 

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 3, not possible get get an ask value'.format(thread_name))

            # option 4: USD and BTC
            if balances.get_coin_balance(exch_0.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and balances.get_coin_balance(exch_1.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_1.name, 'BTC')['trading_size'] \
                and quote_coin + '/USD' in exch_0.markets.keys() \
                and base_coin + '/BTC' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 4 cash in USD coin in first exch and cash in BTC in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using USD), exch1: BUY base coin using BTC
                    pair_to_buy_0 = quote_coin + '/USD'
                    pair_to_buy_1 = base_coin + '/BTC'
                    option_4_tz_base = balances.get_coin_balance(exch_0.name, quote_coin)['trading_size']
                    option_4_tz_quote = balances.get_coin_balance(exch_1.name, base_coin)['trading_size']
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # USD
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, option_4_tz_base * profit)  # update profit on one of the exchanges

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 4, not possible get get an ask value'.format(thread_name))

            # option 4': USD and BTC (reverse option on BTC)
            if balances.get_coin_balance(exch_0.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and balances.get_coin_balance(exch_1.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_1.name, 'BTC')['trading_size'] \
                and quote_coin + '/USD' in exch_0.markets.keys() \
                and 'BTC/' + base_coin in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 4\' cash in USD coin in first exch and cash in BTC in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using USD), exch1: SELL BTC to get base curr
                    pair_to_buy_0 = quote_coin + '/USD'
                    pair_to_sell_1 = 'BTC/' + base_coin
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    bid_1 = get_selling_price(exch_1, pair_to_sell_1, tz_BTC)
                    if ask_0 and bid_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # USD
                        selling_order_demo (exch_1, pair_to_sell_1, bid_1, tz_BTC, fee_1)  # BTC
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, option_4_tz_base * profit)  # update profit on one of the exchanges

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 4\', not possible get get an ask value'.format(thread_name))

            # option 5: BTC and USD TODO: reverse option on BTC
            if balances.get_coin_balance(exch_0.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_0.name, 'BTC')['trading_size'] \
                and balances.get_coin_balance(exch_1.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE\
                and quote_coin + '/BTC' in exch_0.markets.keys() \
                and base_coin + '/USD' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 5 cash in BTC coin in first exch and cash in USD in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using BTC), exch1: BUY base using USD
                    pair_to_buy_0 = quote_coin + '/BTC'
                    pair_to_buy_1 = base_coin + '/USD'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # USD
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)  # update profit on one of the exchanges

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 5, not possible get get an ask value'.format(thread_name))

            # TODO:option 5': BTC and USD reverse option on BTC
            if balances.get_coin_balance(exch_0.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_0.name, 'BTC')['trading_size'] \
                and balances.get_coin_balance(exch_1.name, 'USD')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE\
                and 'BTC/' + quote_coin in exch_0.markets.keys() \
                and base_coin + '/USD' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 5\' cash in BTC coin in first exch and cash in USD in second exch'.format(thread_name))

                    # TODO: exch0: SELL BTC to get quote, exch1: BUY base using USD
                    pair_to_sell_0 = 'BTC/' + quote_coin
                    pair_to_buy_1 = base_coin + '/USD'
                    bid_0 = get_selling_price(exch_0, pair_to_sell_0, tz_BTC)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if bid_0 and ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo (exch_0, pair_to_sell_0, bid_0, tz_BTC, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # USD
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)  # update profit on one of the exchanges

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 5\', not possible get get an ask value'.format(thread_name))

            # option 6: BTC and BTC  TODO: reverse option
            if balances.get_coin_balance(exch_0.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_0.name, 'BTC')['trading_size'] \
                and balances.get_coin_balance(exch_1.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_1.name, 'BTC')['trading_size']\
                and quote_coin + '/BTC' in exch_0.markets.keys() \
                and base_coin + '/BTC' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 6 cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))
                    pair_to_buy_0 = quote_coin + '/BTC'
                    pair_to_buy_1 = base_coin + '/BTC'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)  # update profit on one of the exchanges

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 6, not possible get get an ask value'.format(thread_name))

            # option 6': BTC and BTC  TODO: reverse option
            if balances.get_coin_balance(exch_0.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_0.name, 'BTC')['trading_size'] \
                and balances.get_coin_balance(exch_1.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_1.name, 'BTC')['trading_size']\
                and 'BTC' + quote_coin in exch_0.markets.keys() \
                and 'BTC' + base_coin in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 6\' cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))
                    pair_to_buy_0 = 'BTC/' + quote_coin
                    pair_to_buy_1 = 'BTC/' + base_coin
                    bid_0 = get_selling_price(exch_0, pair_to_buy_0, tz_BTC)
                    bid_1 = get_selling_price(exch_1, pair_to_buy_1, tz_BTC)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo (exch_0, pair_to_buy_0, bid_0, tz_BTC, fee_0)  # BTC
                        selling_order_demo (exch_1, pair_to_buy_1, bid_1, tz_BTC, fee_1)  # BTC
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)  # update profit on one of the exchanges

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 6\', not possible get get an ask value'.format(thread_name))

            # TODO: option 7: base and BTC  (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN BASE IN THE SECOND EXCHANGE)
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base * (1+fee_0) \
                and balances.get_coin_balance(exch_1.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_1.name, 'BTC')['trading_size']\
                and base_coin + '/BTC' in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 7 cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))            
                    # TODO exch0: buy quote using BTC exch1: buy base using BTC
                    pair_to_buy_1 = base_coin + '/BTC'
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)                           # base
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 7, not possible get get an ask value'.format(thread_name))

            # TODO: option 7': base and BTC  (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN BASE IN THE SECOND EXCHANGE)
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base * (1+fee_0) \
                and balances.get_coin_balance(exch_1.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_1.name, 'BTC')['trading_size']\
                and 'BTC/' + base_coin in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 7\' cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))            
                    # TODO exch0: buy quote using BTC exch1: buy base using BTC
                    pair_to_buy_1 = 'BTC/' + base_coin
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_BTC)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)                           # base
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_BTC, fee_1)  # BTC
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 7\', not possible get get an ask value'.format(thread_name))

            # TODO: option 8: BTC and quote (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN QUOTE IN THE FIRST EXCHANGE)
            if balances.get_coin_balance(exch_0.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * (tz_quote * (1+fee_1) * ask) \
                and quote_coin + '/BTC' in exch_0.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 8 cash in BTC in first exch and cash in quote coin in second exch'.format(thread_name))
                    
                    # exch0: buy quote coin using BTC, exch1: buy base coin (using quote)
                    pair_to_buy = quote_coin + '/BTC'
                    ask_0 = get_buying_price(exch_0, pair_to_buy, tz_quote)
                    if ask:
                        # ----------------------------------------------------------------------
                        buying_order_demo(exch_0, pair_to_buy, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_quote * profit)  # update profit on one of the exchanges<- TODO

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 8, not possible get get an ask value'.format(thread_name))

            # TODO: option 8`: BTC and quote (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN QUOTE IN THE FIRST EXCHANGE)
            if balances.get_coin_balance(exch_0.name, 'BTC')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * (tz_quote * (1+fee_1) * ask) \
                and 'BTC/' + quote_coin in exch_0.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 8 cash in BTC in first exch and cash in quote coin in second exch'.format(thread_name))
                    
                    # exch0: buy quote coin using BTC, exch1: buy base coin (using quote)
                    pair_to_buy = 'BTC/' + quote_coin
                    bid_0 = get_buying_price(exch_0, pair_to_buy, tz_BTC)
                    if ask:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, pair_to_buy, bid_0, tz_BTC, fee_0)  # BTC
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_quote * profit)  # update profit on one of the exchanges<- TODO

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 8\', not possible get get a bid value'.format(thread_name))

            # option 9 : base and EUR
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base * (1+fee_0) \
                and balances.get_coin_balance(exch_1.name, 'EUR')['amount'] >= TRADING_SIZE_MARGIN * balances.get_coin_balance(exch_1.name, 'EUR')['trading_size']\
                and base_coin + '/EUR' in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 7 cash in EUR coin in first exch and cash in EUR in second exch'.format(thread_name))            
                    # TODO exch0: buy quote using EUR exch1: buy base using EUR
                    pair_to_buy_1 = base_coin + '/EUR'
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)                           # base
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # EUR
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_base * profit)

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 9, not possible get get an ask value'.format(thread_name))
                    
            # option 10: EUR and quote
            if balances.get_coin_balance(exch_0.name, 'EUR')['amount'] >= TRADING_SIZE_MARGIN * TRADING_SIZE \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * (tz_quote * (1+fee_1) * ask) \
                and quote_coin + '/EUR' in exch_0.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 8 cash in EUR in first exch and cash in quote coin in second exch'.format(thread_name))
                    
                    # exch0: buy quote coin using EUR, exch1: buy base coin (using quote)
                    pair_to_buy = quote_coin + '/EUR'
                    ask_0 = get_buying_price(exch_0, pair_to_buy, tz_quote)
                    if ask:
                        # ----------------------------------------------------------------------
                        buying_order_demo(exch_0, pair_to_buy, ask_0, tz_quote, fee_0)  # EUR
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------
                        balances.update_profit(exch_0.name, base_coin, tz_quote * profit)  # update profit on one of the exchanges<- TODO

                        acc_eq_base_exch_0 += tz_base * (1 + profit) 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        ready_to_exit = False
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 10, not possible get get an ask value'.format(thread_name))

            # option 11: EUR and EUR
            # if balances.get_coin_balance(exch_0.name, 'EUR')['amount'] >= balances.get_coin_balance(exch_0.name, 'EUR')['trading_size'] \
            #     and balances.get_coin_balance(exch_1.name, 'EUR')['amount'] >= balances.get_coin_balance(exch_1.name, 'EUR')['trading_size']\
            #     and quote_coin + '/EUR' in exch_0.markets.keys() \
            #     and base_coin + '/EUR' in exch_1.markets.keys()\
            #     and keep_running:
            #         logger.info('{} OPTION 11 cash in EUR coin in first exch and cash in EUR in second exch'.format(thread_name))            
                    
            # # option 12: EUR and USD
            # if balances.get_coin_balance(exch_0.name, 'EUR')['amount'] >= balances.get_coin_balance(exch_0.name, 'EUR')['trading_size'] \
            #     and balances.get_coin_balance(exch_1.name, 'USD')['amount'] >= balances.get_coin_balance(exch_1.name, 'USD')['trading_size']\
            #     and quote_coin + '/EUR' in exch_0.markets.keys() \
            #     and base_coin + '/USD' in exch_1.markets.keys()\
            #     and keep_running:
            #         logger.info('{} OPTION 12 cash in EUR coin in first exch and cash in EUR in second exch'.format(thread_name))            
                    
            # # option 13: USD and EUR
            # if balances.get_coin_balance(exch_0.name, 'USD')['amount'] >= balances.get_coin_balance(exch_0.name, 'USD')['trading_size'] \
            #     and balances.get_coin_balance(exch_1.name, 'EUR')['amount'] >= balances.get_coin_balance(exch_1.name, 'EUR')['trading_size']\
            #     and quote_coin + '/USD' in exch_0.markets.keys() \
            #     and base_coin + '/EUR' in exch_1.markets.keys()\
            #     and keep_running:
            #         logger.info('{} OPTION 13 cash in USD coin in first exch and cash in EUR in second exch'.format(thread_name))            

            # # option 14: EUR and BTC
            # if balances.get_coin_balance(exch_0.name, 'EUR')['amount'] >= balances.get_coin_balance(exch_0.name, 'EUR')['trading_size'] \
            #     and balances.get_coin_balance(exch_1.name, 'BTC')['amount'] >= balances.get_coin_balance(exch_1.name, 'BTC')['trading_size']\
            #     and quote_coin + '/EUR' in exch_0.markets.keys() \
            #     and base_coin + '/BTC' in exch_1.markets.keys() \
            #     and keep_running:
            #         logger.info('{} OPTION 14 cash in EUR coin in first exch and cash in EUR in second exch'.format(thread_name))            

            # # option 15: BTC and EUR
            # if balances.get_coin_balance(exch_0.name, 'BTC')['amount'] >= balances.get_coin_balance(exch_0.name, 'BTC')['trading_size'] \
            #     and balances.get_coin_balance(exch_1.name, 'EUR')['amount'] >= TRADING_SIZE\
            #     and quote_coin + '/BTC' in exch_0.markets.keys() \
            #     and base_coin + '/EUR' in exch_1.markets.keys()\
            #     and keep_running:
            #         logger.info('{} OPTION 15 cash in BTC coin in first exch and cash in EUR in second exch'.format(thread_name))
            
            # TODO: include options for EUR

            if keep_running:
                logger.warning('{}: not enough cash for ordering selling-buying'.format(thread_name))
                
        else:
            logger.info('{}: trading not possible, net profit: \t{}'.format(thread_name, profit))

            iterations_failed += 1

        if profit <= PROFIT_THR_TO_CLOSE_POSITIONS and acc_eq_base_exch_0 >= TRADES_TO_ALLOW_CLOSING * tz_quote:
            # closing normal trade positions, those comming from OPTION 0
            logger.info('{} CLOSING DIRECT TRADING POSITIONS'.format(thread_name))

            # TODO: CODE THIS PROCEDURE
            buying_order_demo (exch_0, base_coin + '/' + quote_coin, ask, acc_eq_base_exch_0, fee_0)
            selling_order_demo(exch_1, base_coin + '/' + quote_coin, bid, acc_base_exch_1, fee_1)

            acc_base_exch_1 = 0
            acc_eq_base_exch_0 = 0
            iterations = 1
            ready_to_exit = True  # TODO: fix this exit option!!!!
            acc_profit = 0
            mean_profit = 0


        elif profit <= NON_DIRECT_CLOSING_PROFIT_THR and acc_eq_base_exch_0 >= TRADES_TO_ALLOW_CLOSING * tz_quote:
            # closing non direct trading positions
            logger.info('{} CLOSING NON DIRECT TRADING POSITIONS'.format(thread_name))

            # sell the accum. traded amounts in stable coins on exch_0  TODO: insert logger strings in the closing options
            # ----------------------------------------------------------------------
            exch_0_ready = False
            if base_coin + '/' + quote_coin in exch_0.markets.keys():
                ask_0 = get_buying_price(exch_0, base_coin + '/' + quote_coin, acc_eq_base_exch_0)  # get the aprox ask using the amount of base moves on exch_1
                
            # and sell the accum. traded amounts in stable coins on exch_1
            # ----------------------------------------------------------------------
            exch_1_ready = False
            if base_coin + '/' + quote_coin in exch_1.markets.keys():
                bid_1 = get_selling_price(exch_1, base_coin + '/' + quote_coin, acc_base_exch_1)
                
            # ----------------------------------------------------------------------
            if bid_1 and ask_0:
                buying_order_demo (exch_0, base_coin + '/' + quote_coin, ask_0, acc_eq_base_exch_0, fee_0)
                acc_eq_base_exch_0 = 0
                exch_0_ready = True

                selling_order_demo(exch_1, base_coin + '/' + quote_coin, bid_1, acc_base_exch_1, fee_1)
                acc_base_exch_1 = 0
                exch_1_ready = True


            if exch_0_ready and exch_1_ready:
                balances.update_profit(exch_0.name, base_coin, -acc_eq_base_exch_0 * profit)
                iterations = 1
                ready_to_exit = True  # TODO: fix this exit option!!!!
                acc_profit = 0
                mean_profit = 0

        else:
            if iterations_failed >= MAX_ITER_TO_EXIT and ready_to_exit:
                logger.info('{} EXITING'.format(thread_name))

                return True
        try:
            # delay time with a bit of stagger to avoid always falling on the same point 
            time.sleep(EXPLOIT_THREAD_DELAY + random.randint(0, 3) - (time.time() - loop_time))
        except:
            pass
