import time
from datetime import datetime
import random

from src.wallet import balances
from src.setup_logger import logger, balance_logger
from src.params import RATE_LIMIT_FACTOR, EXPLOIT_THREAD_DELAY, OPERATE_THR_FACTOR, PROFIT_THR_TO_OPEN_POSITIONS, NON_DIRECT_TRADE_PROFIT_THR, NON_DIRECT_CLOSING_PROFIT_THR
from src.params import TRADING_SIZE_MARGIN, TRADING_SIZE, TRADES_TO_ALLOW_CLOSING, PROFIT_THR_TO_CLOSE_POSITIONS, MAX_ITER_TO_EXIT
from src.storage import storage
from src.selling_buying import selling_order_demo, buying_order_demo, get_selling_price, get_buying_price


current_milli_time = lambda: int(round(time.time() * 1000))

def exploit_thread(exch_0, exch_1, coin_pair, coin_pairs_avail):
    """
        exploit thread
        it tracks a profit tendency between exchanges and coins pair
        stores the profit until the tendence turns into negative or not profitable
    """

    RATE_LIMIT_FACTOR = 1  # set a lower

    # compose the log filename using exchanges and coins pair
    filename = './logs/' + exch_0.name + '-' + exch_1.name + '-' + coin_pair.replace('/', '-') + '.csv'


    thread_name = storage.exploit_threads[-1].getName()
    storage.threads_status.append({'thread_name': thread_name,
                                   'is alive': 'True',
                                   'last iter profit': 0
                                   })

    thread_index = next((index for index, item in enumerate(storage.threads_status) if item['thread_name']==thread_name), None)
    logger.info('{} STARTING'.format(thread_name))

    # movements accumulated
    acc_base_exch_0 = 0  # accum equivalent base amoun on exch_0
    acc_base_exch_1 = 0     # on exch 1

    # statistics data, still not used
    iterations = 0
    iterations_failed = 0
    acc_profit = 0

    mean_profit = 0
    acc_sell_price = 0
    mean_sell_price = 0 # mean base selling price in exch_0
    acc_buy_price = 0
    mean_buy_price = 0  # mean base buying price in exch_1 
    ready_to_exit = True

    while True:
        loop_time = time.time()
        now = datetime.now()

        if  exch_0.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_0.lastRestRequestTimestamp) > 0:
            time.sleep((exch_0.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_0.lastRestRequestTimestamp))/1000)

        if  exch_1.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_1.lastRestRequestTimestamp) > 0:
            time.sleep((exch_1.rateLimit * RATE_LIMIT_FACTOR - (current_milli_time() - exch_1.lastRestRequestTimestamp))/1000)
        
        # gets the trading sizes and coins names
        base_coin = coin_pair.split('/')[0]
        quote_coin = coin_pair.split('/')[1]

        tz_base = balances.get_coin_balance(exch_0.name, base_coin)['trading_size']
        tz_quote = balances.get_coin_balance(exch_1.name, quote_coin)['trading_size']
        tz_BTC = balances.get_coin_balance(exch_1.name, 'BTC')['trading_size']
        tz_USD = balances.get_coin_balance(exch_1.name, 'USD')['trading_size']
        tz_EUR = balances.get_coin_balance(exch_1.name, 'EUR')['trading_size']

        base_coin_balance_0 = balances.get_coin_balance(exch_0.name, base_coin)['total']
        quote_coin_balance_1 = balances.get_coin_balance(exch_1.name, quote_coin)['total']

        base_coin_balance_1 = balances.get_coin_balance(exch_1.name, base_coin)['total']
        quote_coin_balance_0 = balances.get_coin_balance(exch_0.name, quote_coin)['total']

        # get the best bid and ask for that amount
        bid = get_selling_price(exch_0, coin_pair, tz_base)
        ask = get_buying_price (exch_1, coin_pair, tz_base)  #tz_quote)

        # gets the fees
        try:
            fee_0 = max(exch_0.fees['trading']['maker'], exch_0.fees['trading']['taker'])
        except:
            fee_0 = 0.005
        try:
            fee_1 = max(exch_1.fees['trading']['maker'], exch_1.fees['trading']['taker'])
        except:
            fee_1 = 0.005

        if not bid or not ask:
            logger.info('{}: not possible get a bid or an ask'.format(thread_name))
            # delay time with a bit of stagger to avoid always falling on same point
            time.sleep(EXPLOIT_THREAD_DELAY + random.randint(0, 3))
            continue

        # figure the profit out. Operation Threshold: factor above fees
        profit = (bid - ask)/ask - OPERATE_THR_FACTOR * (fee_0 + fee_1)

        keep_running = True
        if profit >= PROFIT_THR_TO_OPEN_POSITIONS:
            logger.info('{}: trading possible, net profit: \t{}'.format(thread_name, profit))
            acc_profit += profit

            # option 0: ideal: base and quote OK
            logger.info('{}: ordering a direct selling-buying for a profit of \t{}'.format(thread_name, profit))

            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base * (1+fee_0) \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * tz_quote:
                    logger.info('{} OPTION 0, ideal situation: cash in base coin in first exch and cash in quote coin in second exch'.format(thread_name))

                    # ----------------------------------------------------------------------
                    selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)
                    buying_order_demo (exch_1, coin_pair, ask, tz_base, fee_1)
                    # ----------------------------------------------------------------------

                    acc_base_exch_0 += tz_base
                    acc_base_exch_1 += tz_base

                    iterations += 1
                    acc_sell_price += bid
                    mean_sell_price = acc_sell_price / iterations
                    acc_buy_price += ask
                    mean_buy_price = acc_buy_price / iterations
                    keep_running = False
                    
                    logger.info('{}: trade performed'.format(thread_name))
                    iterations_failed = 0
                    ready_to_exit = False
                    mean_profit = acc_profit/iterations
        else:
            logger.info('{}: trading NOT possible, net profit: \t{}'.format(thread_name, profit))
            iterations_failed += 1
        
        # if coin pair has some of the stable coins (USD, BTC or EUR) TODO: include USDT or/and USDC and similar.
        # this is for not buying USD, BTC, EUR if we already have them. Here we only perform tades on one exchange.
        if keep_running \
            and (base_coin == 'USD' or quote_coin == 'USD' or base_coin == 'BTC' or quote_coin == 'BTC' or base_coin == 'EUR' or quote_coin == 'EUR'):
            logger.info('{}: direct trading not possible, trying to trade only in one exchange cause we have stableCoins'.format(thread_name))

            if base_coin == 'USD':
                pass

            if quote_coin == 'USD' \
                and balances.get_coin_balance(exch_0.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and balances.get_coin_balance(exch_1.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and keep_running:
                    logger.info('{} OPTION 0.2 quote coin is USD'.format(thread_name))

                    pair_to_buy_1 = base_coin + '/USD'
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)   # USD
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 0.2, not possible get get an ask value'.format(thread_name))

            if base_coin == 'BTC' \
                and balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and keep_running:
                    logger.info('{} OPTION 0.3 cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))
                    pair_to_sell_0 = 'BTC/' + quote_coin
                    bid_0 = get_selling_price(exch_0, pair_to_sell_0, tz_BTC)
                    if bid_0:
                        # ----------------------------------------------------------------------
                        selling_order_demo (exch_0, pair_to_sell_0, bid_0, tz_BTC, fee_0)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 0.3, not possible get get an ask value'.format(thread_name))

            if quote_coin == 'BTC' \
                and balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and base_coin + '/BTC' in exch_0.markets.keys() \
                and base_coin + '/BTC' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 0.4 cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))
                    pair_to_buy_1 = base_coin + '/BTC'
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 0.4, not possible get get an ask value'.format(thread_name))

            if base_coin == 'EUR':
                pass

            if quote_coin == 'EUR' \
                and balances.get_coin_balance(exch_0.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and balances.get_coin_balance(exch_1.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and keep_running:
                    logger.info('{} OPTION 0.6 cash in EUR coin in first exch and cash in EUR in second exch'.format(thread_name))
                    pair_to_buy_1 = base_coin + '/EUR'
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)   # EUR
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 0.6, not possible get get an ask value'.format(thread_name))

        if keep_running \
           and profit >= NON_DIRECT_TRADE_PROFIT_THR:  # here we have to set a higher threshold since we could get into big losses ...
            logger.info('{}: direct trading not possible, trying a non direct arb, net profit: \t{}'.format(thread_name, profit))
            acc_profit += profit

            # option 1: USD and quote OK
            if balances.get_coin_balance(exch_0.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * tz_quote \
                and quote_coin + '/USD' in exch_0.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 1 cash in USD in first exch and cash in quote coin in second exch'.format(thread_name))

                    # exch0: buy quote coin using USD, exch1: buy base coin (using quote)
                    pair_to_buy = quote_coin + '/USD'
                    ask_0 = get_buying_price(exch_0, pair_to_buy, tz_quote)
                    if ask_0:
                        # ----------------------------------------------------------------------
                        buying_order_demo(exch_0, pair_to_buy, ask_0, tz_quote, fee_0)  # USD
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base
                        acc_base_exch_1 += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 1, not possible get get an ask value'.format(thread_name))

            # option 2: base and USD OK
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base \
                and balances.get_coin_balance(exch_1.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and base_coin + '/USD' in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 2 cash in base coin in first exch and cash in USD in second exch'.format(thread_name))

                    # exch0: SELL base coin (using quote), exch1: BUY base coin using USD
                    pair_to_buy = base_coin + '/USD'
                    ask_1 = get_buying_price(exch_1, pair_to_buy, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)
                        buying_order_demo (exch_1, pair_to_buy, ask_1, tz_base, fee_1)  # USD
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base
                        acc_base_exch_1 += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 2, not possible get get an ask value'.format(thread_name))

            # option 3: USD and USD
            if balances.get_coin_balance(exch_0.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and balances.get_coin_balance(exch_1.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and quote_coin + '/USD' in exch_0.markets.keys() \
                and base_coin + '/USD' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 3 cash in USD coin in first exch and cash in USD in second exch'.format(thread_name))

                    #exch0: BUY quote coin (using USD), exch1: BUY base coin using USD
                    pair_to_buy_0 = quote_coin + '/USD'
                    pair_to_buy_1 = base_coin + '/USD'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # USD
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)   # USD
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 3, not possible get get an ask value'.format(thread_name))

            # option 4: USD and BTC
            if balances.get_coin_balance(exch_0.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC\
                and quote_coin + '/USD' in exch_0.markets.keys() \
                and base_coin + '/BTC' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 4 cash in USD coin in first exch and cash in BTC in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using USD), exch1: BUY base coin using BTC
                    pair_to_buy_0 = quote_coin + '/USD'
                    pair_to_buy_1 = base_coin + '/BTC'
                    # option_4_tz_base = balances.get_coin_balance(exch_0.name, quote_coin)['trading_size']
                    # option_4_tz_quote = balances.get_coin_balance(exch_1.name, base_coin)['trading_size']
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # USD
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)   # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 4, not possible get get an ask value'.format(thread_name))

            # option 4': USD and BTC (reverse option on BTC)
            if balances.get_coin_balance(exch_0.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and quote_coin + '/USD' in exch_0.markets.keys() \
                and 'BTC/' + base_coin in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 4\' cash in USD coin in first exch and cash in BTC in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using USD), exch1: SELL BTC to get base curr
                    pair_to_buy_0 = quote_coin + '/USD'
                    pair_to_sell_1 = 'BTC/' + base_coin
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    bid_1 = get_selling_price(exch_1, pair_to_sell_1, tz_BTC)
                    if ask_0 and bid_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # USD
                        selling_order_demo (exch_1, pair_to_sell_1, bid_1, tz_BTC, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 4\', not possible get get an ask value'.format(thread_name))

            # option 5: BTC and USD TODO: reverse option on BTC
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD\
                and quote_coin + '/BTC' in exch_0.markets.keys() \
                and base_coin + '/USD' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 5 cash in BTC coin in first exch and cash in USD in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using BTC), exch1: BUY base using USD
                    pair_to_buy_0 = quote_coin + '/BTC'
                    pair_to_buy_1 = base_coin + '/USD'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # USD
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 5, not possible get get an ask value'.format(thread_name))

            # TODO:option 5': BTC and USD reverse option on BTC
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and 'BTC/' + quote_coin in exch_0.markets.keys() \
                and base_coin + '/USD' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 5\' cash in BTC coin in first exch and cash in USD in second exch'.format(thread_name))

                    # TODO: exch0: SELL BTC to get quote, exch1: BUY base using USD
                    pair_to_sell_0 = 'BTC/' + quote_coin
                    pair_to_buy_1 = base_coin + '/USD'
                    bid_0 = get_selling_price(exch_0, pair_to_sell_0, tz_BTC)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if bid_0 and ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo (exch_0, pair_to_sell_0, bid_0, tz_BTC, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # USD
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 5\', not possible get get an ask value'.format(thread_name))

            # option 6: BTC and BTC  TODO: reverse option
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and quote_coin + '/BTC' in exch_0.markets.keys() \
                and base_coin + '/BTC' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 6 cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))
                    pair_to_buy_0 = quote_coin + '/BTC'
                    pair_to_buy_1 = base_coin + '/BTC'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 6, not possible get get an ask value'.format(thread_name))

            # option 6': BTC and BTC  TODO: reverse option
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and 'BTC/' + quote_coin in exch_0.markets.keys() \
                and 'BTC/' + base_coin in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 6\' cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))
                    pair_to_buy_0 = 'BTC/' + quote_coin
                    pair_to_buy_1 = 'BTC/' + base_coin
                    bid_0 = get_selling_price(exch_0, pair_to_buy_0, tz_BTC)
                    bid_1 = get_selling_price(exch_1, pair_to_buy_1, tz_BTC)
                    if bid_0 and bid_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo (exch_0, pair_to_buy_0, bid_0, tz_BTC, fee_0)  # BTC
                        selling_order_demo (exch_1, pair_to_buy_1, bid_1, tz_BTC, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 6\', not possible get get an ask value'.format(thread_name))

            # TODO: option 7: base and BTC  (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN BASE IN THE SECOND EXCHANGE)
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and base_coin + '/BTC' in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 7 cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))            
                    # TODO exch0: buy quote using BTC exch1: buy base using BTC
                    pair_to_buy_1 = base_coin + '/BTC'
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)                           # base
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 7, not possible get get an ask value'.format(thread_name))

            # TODO: option 7': base and BTC  (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN BASE IN THE SECOND EXCHANGE)
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and 'BTC/' + base_coin in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 7\' cash in BTC coin in first exch and cash in BTC in second exch'.format(thread_name))            
                    # TODO exch0: buy quote using BTC exch1: buy base using BTC
                    pair_to_buy_1 = 'BTC/' + base_coin
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_BTC)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)                           # base
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_BTC, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 7\', not possible get get an ask value'.format(thread_name))

            # TODO: option 8: BTC and quote (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN QUOTE IN THE FIRST EXCHANGE)
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * tz_quote \
                and quote_coin + '/BTC' in exch_0.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 8 cash in BTC in first exch and cash in quote coin in second exch'.format(thread_name))
                    
                    # exch0: buy quote coin using BTC, exch1: buy base coin (using quote)
                    pair_to_buy = quote_coin + '/BTC'
                    ask_0 = get_buying_price(exch_0, pair_to_buy, tz_quote)
                    if ask_0:
                        # ----------------------------------------------------------------------
                        buying_order_demo(exch_0, pair_to_buy, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 8, not possible get get an ask value'.format(thread_name))

            # TODO: option 8`: BTC and quote (FINISH THE SECOND OPTION SELLING BTC TO OBTAIN QUOTE IN THE FIRST EXCHANGE)
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_USD \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * tz_quote \
                and 'BTC/' + quote_coin in exch_0.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 8 cash in BTC in first exch and cash in quote coin in second exch'.format(thread_name))
                    
                    # exch0: buy quote coin using BTC, exch1: buy base coin (using quote)
                    pair_to_buy = 'BTC/' + quote_coin
                    bid_0 = get_buying_price(exch_0, pair_to_buy, tz_BTC)
                    if bid_0:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, pair_to_buy, bid_0, tz_BTC, fee_0)  # BTC
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 8\', not possible get get a bid value'.format(thread_name))

            # option 9 : base and EUR
            if base_coin_balance_0 >= TRADING_SIZE_MARGIN * tz_base \
                and balances.get_coin_balance(exch_1.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR\
                and base_coin + '/EUR' in exch_1.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 9 cash in EUR coin in first exch and cash in EUR in second exch'.format(thread_name))            
                    # TODO exch0: buy quote using EUR exch1: buy base using EUR
                    pair_to_buy_1 = base_coin + '/EUR'
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo(exch_0, coin_pair, bid, tz_base, fee_0)
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 9, not possible get get an ask value'.format(thread_name))
                    
            # option 10: EUR and quote
            if balances.get_coin_balance(exch_0.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and quote_coin_balance_1 >= TRADING_SIZE_MARGIN * tz_quote \
                and quote_coin + '/EUR' in exch_0.markets.keys()\
                and keep_running:
                    logger.info('{} OPTION 10 cash in EUR in first exch and cash in quote coin in second exch'.format(thread_name))
                    
                    # exch0: buy quote coin using EUR, exch1: buy base coin (using quote)
                    pair_to_buy = quote_coin + '/EUR'
                    ask_0 = get_buying_price(exch_0, pair_to_buy, tz_quote)
                    if ask_0:
                        # ----------------------------------------------------------------------
                        buying_order_demo(exch_0, pair_to_buy, ask_0, tz_quote, fee_0)
                        buying_order_demo(exch_1, coin_pair, ask, tz_base, fee_1)
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 10, not possible get get an ask value'.format(thread_name))

            # option 11: EUR and EUR
            if balances.get_coin_balance(exch_0.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and balances.get_coin_balance(exch_1.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and quote_coin + '/EUR' in exch_0.markets.keys() \
                and base_coin + '/EUR' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 11 cash in EUR coin in first exch and cash in EUR in second exch'.format(thread_name))
                    pair_to_buy_0 = quote_coin + '/EUR'
                    pair_to_buy_1 = base_coin + '/EUR'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # EUR
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)   # EUR
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 11, not possible get get an ask value'.format(thread_name))
                    
            # # option 12: EUR and USD
            if balances.get_coin_balance(exch_0.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR\
                and balances.get_coin_balance(exch_1.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD\
                and quote_coin + '/EUR' in exch_0.markets.keys() \
                and base_coin + '/USD' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 12 cash in EUR coin in first exch and cash in USD in second exch'.format(thread_name))
                    pair_to_buy_0 = quote_coin + '/EUR'
                    pair_to_buy_1 = base_coin + '/USD'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 12, not possible get get an ask value'.format(thread_name))
                    
            # # option 13: USD and EUR
            if balances.get_coin_balance(exch_0.name, 'USD')['total'] >= TRADING_SIZE_MARGIN * tz_USD\
                and balances.get_coin_balance(exch_1.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR\
                and quote_coin + '/USD' in exch_0.markets.keys() \
                and base_coin + '/EUR' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 13 cash in USD coin in first exch and cash in EUR in second exch'.format(thread_name))
                    pair_to_buy_0 = quote_coin + '/USD'
                    pair_to_buy_1 = base_coin + '/EUR'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 13, not possible get get an ask value'.format(thread_name))

            # # option 14: EUR and BTC
            if balances.get_coin_balance(exch_0.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and quote_coin + '/EUR' in exch_0.markets.keys() \
                and base_coin + '/BTC' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 14 cash in EUR coin in first exch and cash in BTC in second exch'.format(thread_name))
                    pair_to_buy_0 = quote_coin + '/EUR'
                    pair_to_buy_1 = base_coin + '/BTC'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 14, not possible get get an ask value'.format(thread_name))

            # TODO: option 14': EUR and BTC
            if balances.get_coin_balance(exch_0.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and balances.get_coin_balance(exch_1.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and quote_coin + '/EUR' in exch_0.markets.keys() \
                and 'BTC/' + base_coin in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 14\' cash in EUR coin in first exch and cash in BTC in second exch'.format(thread_name))

                    # TODO: exch0: BUY quote coin (using EUR), exch1: SELL BTC to get base curr
                    pair_to_buy_0 = quote_coin + '/EUR'
                    pair_to_sell_1 = 'BTC/' + base_coin
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    bid_1 = get_selling_price(exch_1, pair_to_sell_1, tz_BTC)
                    if ask_0 and bid_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # EUR
                        selling_order_demo (exch_1, pair_to_sell_1, bid_1, tz_BTC, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 14\', not possible get get an ask value'.format(thread_name))

            # option 15: BTC and EUR
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and quote_coin + '/BTC' in exch_0.markets.keys() \
                and base_coin + '/EUR' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 15 cash in BTC coin in first exch and cash in EUR in second exch'.format(thread_name))
                    pair_to_buy_0 = quote_coin + '/BTC'
                    pair_to_buy_1 = base_coin + '/EUR'
                    ask_0 = get_buying_price(exch_0, pair_to_buy_0, tz_quote)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if ask_0 and ask_1:
                        # ----------------------------------------------------------------------
                        buying_order_demo (exch_0, pair_to_buy_0, ask_0, tz_quote, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # BTC
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 15, not possible get get an ask value'.format(thread_name))
            
            # TODO: option 15': BTC and EUR
            if balances.get_coin_balance(exch_0.name, 'BTC')['total'] >= TRADING_SIZE_MARGIN * tz_BTC \
                and balances.get_coin_balance(exch_1.name, 'EUR')['total'] >= TRADING_SIZE_MARGIN * tz_EUR \
                and 'BTC/' + quote_coin in exch_0.markets.keys() \
                and base_coin + '/EUR' in exch_1.markets.keys() \
                and keep_running:
                    logger.info('{} OPTION 15\' cash in BTC coin in first exch and cash in EUR in second exch'.format(thread_name))

                    # TODO: exch0: SELL BTC to get quote, exch1: BUY base using EUR
                    pair_to_sell_0 = 'BTC/' + quote_coin
                    pair_to_buy_1 = base_coin + '/EUR'
                    bid_0 = get_selling_price(exch_0, pair_to_sell_0, tz_BTC)
                    ask_1 = get_buying_price(exch_1, pair_to_buy_1, tz_base)
                    if bid_0 and ask_1:
                        # ----------------------------------------------------------------------
                        selling_order_demo (exch_0, pair_to_sell_0, bid_0, tz_BTC, fee_0)  # BTC
                        buying_order_demo (exch_1, pair_to_buy_1, ask_1, tz_base, fee_1)  # EUR
                        # ----------------------------------------------------------------------

                        acc_base_exch_0 += tz_base 
                        acc_base_exch_1  += tz_base

                        iterations += 1
                        acc_sell_price += bid
                        mean_sell_price = acc_sell_price / iterations
                        acc_buy_price += ask
                        mean_buy_price = acc_buy_price / iterations
                        keep_running = False
                    else:
                        logger.info('{}: OPTION 15\', not possible get get an ask value'.format(thread_name))

            if not keep_running:
                logger.info('{}: non direct trade performed'.format(thread_name))
                iterations_failed = 0
                ready_to_exit = False
                mean_profit = acc_profit/iterations
            else:
                logger.info('{}: non direct trading was not possible, all options exhausted'.format(thread_name))
                
        if profit <= PROFIT_THR_TO_CLOSE_POSITIONS and acc_base_exch_0 >= TRADES_TO_ALLOW_CLOSING * tz_base:
            # closing normal trade positions, those comming from OPTION 0
            logger.info('{} TRYING TO CLOSE DIRECT TRADING POSITIONS'.format(thread_name))            
            
            ask_0 = get_buying_price(exch_0, base_coin + '/' + quote_coin, acc_base_exch_0)
            bid_1 = get_selling_price(exch_1, base_coin + '/' + quote_coin, acc_base_exch_1)
            logger.info('{} mean sell price: {}, ask: {} / mean buy price {}, bid_ {}'.format(thread_name, mean_sell_price, ask_0, mean_buy_price, bid_1))

            if ask_0 and bid_1 and mean_sell_price >= .99* ask_0 and mean_buy_price <= 1.01* bid_1:
                logger.info('{} CLOSING DIRECT TRADE POSITIONS'.format(thread_name))
                
                buying_order_demo (exch_0, base_coin + '/' + quote_coin, ask, acc_base_exch_0, fee_0)
                acc_base_exch_0 = 0

                selling_order_demo(exch_1, base_coin + '/' + quote_coin, bid, acc_base_exch_1, fee_1)
                acc_base_exch_1 = 0
                
                iterations = 0
                ready_to_exit = True
                acc_sell_price = 0
                acc_buy_price = 0
                mean_sell_price = 0
                mean_buy_price = 0
            
            else:
                logger.info('{} CLOSING DIRECT POSITIONS NOT POSSIBLE '.format(thread_name))

        elif profit <= NON_DIRECT_CLOSING_PROFIT_THR and acc_base_exch_0 >= TRADES_TO_ALLOW_CLOSING * tz_base:
            # closing non direct trading positions
            logger.info('{} TRYING TO CLOSE NON DIRECT TRADING POSITIONS'.format(thread_name))

            # TODO: insert logger strings in the closing options
            # ----------------------------------------------------------------------
            if base_coin + '/' + quote_coin in exch_0.markets.keys():
                ask_0 = get_buying_price(exch_0, base_coin + '/' + quote_coin, acc_base_exch_0)
                
            if base_coin + '/' + quote_coin in exch_1.markets.keys():
                bid_1 = get_selling_price(exch_1, base_coin + '/' + quote_coin, acc_base_exch_1)
            # ----------------------------------------------------------------------

            if bid_1 and ask_0 and mean_sell_price >= ask_0 and mean_buy_price <= bid_1:
                logger.info('{} CLOSING NON DIRECT TRADE POSITIONS'.format(thread_name))

                buying_order_demo (exch_0, base_coin + '/' + quote_coin, ask_0, acc_base_exch_0, fee_0)
                acc_base_exch_0 = 0

                selling_order_demo(exch_1, base_coin + '/' + quote_coin, bid_1, acc_base_exch_1, fee_1)
                acc_base_exch_1 = 0

                iterations = 0
                ready_to_exit = True
                acc_sell_price = 0
                acc_buy_price = 0
                mean_sell_price = 0
                mean_buy_price = 0
                
            else:
                logger.info('{} CLOSING NON DIRECT POSITIONS NOT POSSIBLE '.format(thread_name))
        
        # stores thread status
        storage.threads_status[thread_index]['last iter profit'] = profit
        storage.threads_status[thread_index]['iterations with trade'] = iterations
        storage.threads_status[thread_index]['iterations without trade'] = iterations_failed
        storage.threads_status[thread_index]['mean profit'] = mean_profit
        storage.threads_status[thread_index]['acc base sold'] = acc_base_exch_0
        storage.threads_status[thread_index]['mean sell price'] = mean_sell_price
        storage.threads_status[thread_index]['acc base bought'] = acc_base_exch_1
        storage.threads_status[thread_index]['mean buy price'] = mean_buy_price

        # kills the thread
        if iterations_failed >= MAX_ITER_TO_EXIT and ready_to_exit:
            logger.info('{} EXITING'.format(thread_name))
            storage.threads_status[thread_index]['is alive'] = 'False'
            # ----------------------------------------------------------------------
            return True  # thread self killing
            # ----------------------------------------------------------------------

        try:
            # delay time with a bit of stagger to avoid always falling on the same point
            time.sleep(EXPLOIT_THREAD_DELAY + random.randint(0, 3) - (time.time() - loop_time))
        except Exception as e:
            logger.error('{} Exception: '.format(thread_name, e))
